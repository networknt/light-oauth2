package com.networknt.oauth.code.handler;

import com.networknt.client.Http2Client;
import com.networknt.config.Config;
import com.networknt.status.Status;
import com.networknt.exception.ClientException;
import io.undertow.UndertowOptions;
import io.undertow.client.ClientConnection;
import io.undertow.client.ClientRequest;
import io.undertow.client.ClientResponse;
import io.undertow.util.*;
import org.apache.commons.lang.ArrayUtils;
import org.ietf.jgss.GSSContext;
import org.ietf.jgss.GSSManager;
import org.ietf.jgss.GSSName;
import org.junit.Assert;
import org.junit.ClassRule;
import org.junit.Ignore;
import org.junit.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.xnio.IoUtils;
import org.xnio.OptionMap;

import javax.security.auth.Subject;
import java.net.URI;
import java.nio.charset.StandardCharsets;
import java.security.PrivilegedExceptionAction;
import java.util.Base64;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.atomic.AtomicReference;

import static com.networknt.client.oauth.OauthHelper.encodeCredentials;
import static com.networknt.oauth.spnego.KerberosKDCUtil.login;
import static io.undertow.util.Headers.*;
import static org.junit.Assert.*;


/**
* Generated by swagger-codegen
*/
public class Oauth2CodeGetHandlerTest {
    @ClassRule
    public static TestServer server = TestServer.getInstance();

    static final Logger logger = LoggerFactory.getLogger(Oauth2CodeGetHandlerTest.class);

    @Test
    public void testAuthorizationCode() throws Exception {
        final Http2Client client = Http2Client.getInstance();
        final CountDownLatch latch = new CountDownLatch(1);
        final ClientConnection connection;
        try {
            connection = client.connect(new URI("https://localhost:6881"), Http2Client.WORKER, Http2Client.SSL, Http2Client.BUFFER_POOL, OptionMap.create(UndertowOptions.ENABLE_HTTP2, true)).get();
        } catch (Exception e) {
            throw new ClientException(e);
        }
        final AtomicReference<ClientResponse> reference = new AtomicReference<>();
        try {
            ClientRequest request = new ClientRequest().setMethod(Methods.GET).setPath("/oauth2/code?response_type=code&client_id=59f347a0-c92d-11e6-9d9d-cec0c932ce01&redirect_uri=http://localhost:8080/authorization");
            request.getRequestHeaders().put(Headers.AUTHORIZATION, "Basic " + encodeCredentials("admin", "123456"));
            connection.sendRequest(request, client.createClientCallback(reference, latch));
            latch.await();
            int statusCode = reference.get().getResponseCode();
            String body = reference.get().getAttachment(Http2Client.RESPONSE_BODY);
            Assert.assertEquals(statusCode, 302);
        } catch (Exception e) {
            logger.error("Exception: ", e);
            throw new ClientException(e);
        } finally {
            IoUtils.safeClose(connection);
        }
    }

    @Test
    public void testCodeWithoutResponseType() throws Exception {
        final Http2Client client = Http2Client.getInstance();
        final CountDownLatch latch = new CountDownLatch(1);
        final ClientConnection connection;
        try {
            connection = client.connect(new URI("https://localhost:6881"), Http2Client.WORKER, Http2Client.SSL, Http2Client.BUFFER_POOL, OptionMap.create(UndertowOptions.ENABLE_HTTP2, true)).get();
        } catch (Exception e) {
            throw new ClientException(e);
        }
        final AtomicReference<ClientResponse> reference = new AtomicReference<>();
        try {
            ClientRequest request = new ClientRequest().setMethod(Methods.GET).setPath("/oauth2/code?client_id=59f347a0-c92d-11e6-9d9d-cec0c932ce01&redirect_uri=http://localhost:8888/authorization");
            request.getRequestHeaders().put(Headers.AUTHORIZATION, "Basic " + encodeCredentials("admin", "123456"));
            connection.sendRequest(request, client.createClientCallback(reference, latch));
            latch.await();
            int statusCode = reference.get().getResponseCode();
            String body = reference.get().getAttachment(Http2Client.RESPONSE_BODY);
            Assert.assertEquals(400, statusCode);
            if(statusCode == 400) {
                Status status = Config.getInstance().getMapper().readValue(body, Status.class);
                Assert.assertNotNull(status);
                Assert.assertEquals("ERR11000", status.getCode());
                Assert.assertEquals("VALIDATOR_REQUEST_PARAMETER_QUERY_MISSING", status.getMessage()); // response_type missing
            }
        } catch (Exception e) {
            logger.error("Exception: ", e);
            throw new ClientException(e);
        } finally {
            IoUtils.safeClose(connection);
        }
    }

    @Test
    public void testCodeWithoutClientId() throws Exception {
        final Http2Client client = Http2Client.getInstance();
        final CountDownLatch latch = new CountDownLatch(1);
        final ClientConnection connection;
        try {
            connection = client.connect(new URI("https://localhost:6881"), Http2Client.WORKER, Http2Client.SSL, Http2Client.BUFFER_POOL, OptionMap.create(UndertowOptions.ENABLE_HTTP2, true)).get();
        } catch (Exception e) {
            throw new ClientException(e);
        }
        final AtomicReference<ClientResponse> reference = new AtomicReference<>();
        try {
            ClientRequest request = new ClientRequest().setMethod(Methods.GET).setPath("/oauth2/code?response_type=code&redirect_uri=http://localhost:8888/authorization");
            request.getRequestHeaders().put(Headers.AUTHORIZATION, "Basic " + encodeCredentials("admin", "123456"));
            connection.sendRequest(request, client.createClientCallback(reference, latch));
            latch.await();
            int statusCode = reference.get().getResponseCode();
            String body = reference.get().getAttachment(Http2Client.RESPONSE_BODY);
            Assert.assertEquals(400, statusCode);
            if(statusCode == 400) {
                Status status = Config.getInstance().getMapper().readValue(body, Status.class);
                Assert.assertNotNull(status);
                Assert.assertEquals("ERR11000", status.getCode());
                Assert.assertEquals("VALIDATOR_REQUEST_PARAMETER_QUERY_MISSING", status.getMessage()); // client_id missing
            }
        } catch (Exception e) {
            logger.error("Exception: ", e);
            throw new ClientException(e);
        } finally {
            IoUtils.safeClose(connection);
        }
    }

    @Test
    public void testCodeWrongPassword() throws Exception {
        final Http2Client client = Http2Client.getInstance();
        final CountDownLatch latch = new CountDownLatch(1);
        final ClientConnection connection;
        try {
            connection = client.connect(new URI("https://localhost:6881"), Http2Client.WORKER, Http2Client.SSL, Http2Client.BUFFER_POOL, OptionMap.create(UndertowOptions.ENABLE_HTTP2, true)).get();
        } catch (Exception e) {
            throw new ClientException(e);
        }
        final AtomicReference<ClientResponse> reference = new AtomicReference<>();
        try {
            ClientRequest request = new ClientRequest().setMethod(Methods.GET).setPath("/oauth2/code?response_type=code&client_id=59f347a0-c92d-11e6-9d9d-cec0c932ce01&redirect_uri=http://localhost:8888/authorization");
            request.getRequestHeaders().put(Headers.AUTHORIZATION, "Basic " + encodeCredentials("admin", "fake"));
            connection.sendRequest(request, client.createClientCallback(reference, latch));
            latch.await();
            int statusCode = reference.get().getResponseCode();
            String body = reference.get().getAttachment(Http2Client.RESPONSE_BODY);
            Assert.assertEquals(401, statusCode);
        } catch (Exception e) {
            logger.error("Exception: ", e);
            throw new ClientException(e);
        } finally {
            IoUtils.safeClose(connection);
        }
    }

    @Test
    public void testCodeInvalidResponseType() throws Exception {
        final Http2Client client = Http2Client.getInstance();
        final CountDownLatch latch = new CountDownLatch(1);
        final ClientConnection connection;
        try {
            connection = client.connect(new URI("https://localhost:6881"), Http2Client.WORKER, Http2Client.SSL, Http2Client.BUFFER_POOL, OptionMap.create(UndertowOptions.ENABLE_HTTP2, true)).get();
        } catch (Exception e) {
            throw new ClientException(e);
        }
        final AtomicReference<ClientResponse> reference = new AtomicReference<>();
        try {
            ClientRequest request = new ClientRequest().setMethod(Methods.GET).setPath("/oauth2/code?response_type=wrong&client_id=59f347a0-c92d-11e6-9d9d-cec0c932ce01&redirect_uri=http://localhost:8888/authorization");
            request.getRequestHeaders().put(Headers.AUTHORIZATION, "Basic " + encodeCredentials("admin", "123456"));
            connection.sendRequest(request, client.createClientCallback(reference, latch));
            latch.await();
            int statusCode = reference.get().getResponseCode();
            String body = reference.get().getAttachment(Http2Client.RESPONSE_BODY);

            Assert.assertEquals(400, statusCode);
            if(statusCode == 400) {
                Status status = Config.getInstance().getMapper().readValue(body, Status.class);
                Assert.assertNotNull(status);
                Assert.assertEquals("ERR11004", status.getCode());
                Assert.assertEquals("VALIDATOR_SCHEMA", status.getMessage()); // response type wrong
            }
        } catch (Exception e) {
            logger.error("Exception: ", e);
            throw new ClientException(e);
        } finally {
            IoUtils.safeClose(connection);
        }
    }

    @Test
    public void testCodeClientNotFound() throws Exception {
        final Http2Client client = Http2Client.getInstance();
        final CountDownLatch latch = new CountDownLatch(1);
        final ClientConnection connection;
        try {
            connection = client.connect(new URI("https://localhost:6881"), Http2Client.WORKER, Http2Client.SSL, Http2Client.BUFFER_POOL, OptionMap.create(UndertowOptions.ENABLE_HTTP2, true)).get();
        } catch (Exception e) {
            throw new ClientException(e);
        }
        final AtomicReference<ClientResponse> reference = new AtomicReference<>();
        try {
            ClientRequest request = new ClientRequest().setMethod(Methods.GET).setPath("/oauth2/code?response_type=code&client_id=fake&redirect_uri=http://localhost:8888/authorization");
            request.getRequestHeaders().put(Headers.AUTHORIZATION, "Basic " + encodeCredentials("admin", "123456"));
            connection.sendRequest(request, client.createClientCallback(reference, latch));
            latch.await();
            int statusCode = reference.get().getResponseCode();
            String body = reference.get().getAttachment(Http2Client.RESPONSE_BODY);
            Assert.assertEquals(404, statusCode);
            if(statusCode == 404) {
                Status status = Config.getInstance().getMapper().readValue(body, Status.class);
                Assert.assertNotNull(status);
                Assert.assertEquals("ERR12014", status.getCode());
                Assert.assertEquals("CLIENT_NOT_FOUND", status.getMessage()); // client not found
            }
        } catch (Exception e) {
            logger.error("Exception: ", e);
            throw new ClientException(e);
        } finally {
            IoUtils.safeClose(connection);
        }
    }

    @Test
    public void testAuthorizationCodePKCE() throws Exception {
        final Http2Client client = Http2Client.getInstance();
        final CountDownLatch latch = new CountDownLatch(1);
        final ClientConnection connection;
        try {
            connection = client.connect(new URI("https://localhost:6881"), Http2Client.WORKER, Http2Client.SSL, Http2Client.BUFFER_POOL, OptionMap.create(UndertowOptions.ENABLE_HTTP2, true)).get();
        } catch (Exception e) {
            throw new ClientException(e);
        }
        final AtomicReference<ClientResponse> reference = new AtomicReference<>();
        try {
            ClientRequest request = new ClientRequest().setMethod(Methods.GET).setPath("/oauth2/code?response_type=code&client_id=59f347a0-c92d-11e6-9d9d-cec0c932ce01&code_challenge=GIDiZShhVObyvaTrpkPM8VPmtMkj_qnBWlDwE7uz90s&code_challenge_method=S256&redirect_uri=http://localhost:8080/authorization");
            request.getRequestHeaders().put(Headers.AUTHORIZATION, "Basic " + encodeCredentials("admin", "123456"));
            connection.sendRequest(request, client.createClientCallback(reference, latch));
            latch.await();
            int statusCode = reference.get().getResponseCode();
            String body = reference.get().getAttachment(Http2Client.RESPONSE_BODY);
            Assert.assertEquals(statusCode, 302);
        } catch (Exception e) {
            logger.error("Exception: ", e);
            throw new ClientException(e);
        } finally {
            IoUtils.safeClose(connection);
        }
        // at this moment, an exception will help as it is redirected to localhost:8080 and it is not up.
    }

    @Test
    public void testCodePKCECodeChallengeMethodInvalid() throws Exception {
        final Http2Client client = Http2Client.getInstance();
        final CountDownLatch latch = new CountDownLatch(1);
        final ClientConnection connection;
        try {
            connection = client.connect(new URI("https://localhost:6881"), Http2Client.WORKER, Http2Client.SSL, Http2Client.BUFFER_POOL, OptionMap.create(UndertowOptions.ENABLE_HTTP2, true)).get();
        } catch (Exception e) {
            throw new ClientException(e);
        }
        final AtomicReference<ClientResponse> reference = new AtomicReference<>();
        try {
            ClientRequest request = new ClientRequest().setMethod(Methods.GET).setPath("/oauth2/code?response_type=code&client_id=59f347a0-c92d-11e6-9d9d-cec0c932ce01&code_challenge=GIDiZShhVObyvaTrpkPM8VPmtMkj_qnBWlDwE7uz90s&code_challenge_method=ABC&redirect_uri=http://localhost:8888/authorization");
            request.getRequestHeaders().put(Headers.AUTHORIZATION, "Basic " + encodeCredentials("admin", "123456"));
            connection.sendRequest(request, client.createClientCallback(reference, latch));
            latch.await();
            int statusCode = reference.get().getResponseCode();
            String body = reference.get().getAttachment(Http2Client.RESPONSE_BODY);
            Assert.assertEquals(400, statusCode);
            if(statusCode == 400) {
                Status status = Config.getInstance().getMapper().readValue(body, Status.class);
                Assert.assertNotNull(status);
                Assert.assertEquals("ERR12033", status.getCode());
                Assert.assertEquals("INVALID_CODE_CHALLENGE_METHOD", status.getMessage());
            }
        } catch (Exception e) {
            logger.error("Exception: ", e);
            throw new ClientException(e);
        } finally {
            IoUtils.safeClose(connection);
        }
    }


    @Test
    public void testCodePKCECodeChallengeTooShort() throws Exception {
        final Http2Client client = Http2Client.getInstance();
        final CountDownLatch latch = new CountDownLatch(1);
        final ClientConnection connection;
        try {
            connection = client.connect(new URI("https://localhost:6881"), Http2Client.WORKER, Http2Client.SSL, Http2Client.BUFFER_POOL, OptionMap.create(UndertowOptions.ENABLE_HTTP2, true)).get();
        } catch (Exception e) {
            throw new ClientException(e);
        }
        final AtomicReference<ClientResponse> reference = new AtomicReference<>();
        try {
            ClientRequest request = new ClientRequest().setMethod(Methods.GET).setPath("/oauth2/code?response_type=code&client_id=59f347a0-c92d-11e6-9d9d-cec0c932ce01&code_challenge=xzmujl&code_challenge_method=S256&redirect_uri=http://localhost:8888/authorization");
            request.getRequestHeaders().put(Headers.AUTHORIZATION, "Basic " + encodeCredentials("admin", "123456"));
            connection.sendRequest(request, client.createClientCallback(reference, latch));
            latch.await();
            int statusCode = reference.get().getResponseCode();
            String body = reference.get().getAttachment(Http2Client.RESPONSE_BODY);
            Assert.assertEquals(400, statusCode);
            if(statusCode == 400) {
                Status status = Config.getInstance().getMapper().readValue(body, Status.class);
                Assert.assertNotNull(status);
                Assert.assertEquals("ERR12034", status.getCode());
                Assert.assertEquals("CODE_CHALLENGE_TOO_SHORT", status.getMessage());
            }
        } catch (Exception e) {
            logger.error("Exception: ", e);
            throw new ClientException(e);
        } finally {
            IoUtils.safeClose(connection);
        }
    }

    @Test
    public void testCodePKCECodeChallengeTooLong() throws Exception {
        final Http2Client client = Http2Client.getInstance();
        final CountDownLatch latch = new CountDownLatch(1);
        final ClientConnection connection;
        try {
            connection = client.connect(new URI("https://localhost:6881"), Http2Client.WORKER, Http2Client.SSL, Http2Client.BUFFER_POOL, OptionMap.create(UndertowOptions.ENABLE_HTTP2, true)).get();
        } catch (Exception e) {
            throw new ClientException(e);
        }
        final AtomicReference<ClientResponse> reference = new AtomicReference<>();
        try {
            ClientRequest request = new ClientRequest().setMethod(Methods.GET).setPath("/oauth2/code?response_type=code&client_id=59f347a0-c92d-11e6-9d9d-cec0c932ce01&code_challenge=xzmujlxzmujl-tX1OgdSrtB3oVFp4G3VHVvGbv81i8Nd-A62qgcmo0VDvOq_EaYJiSaM4fsx6oEqhHZfzhTcmcU4WjUAxzmujl-tX1OgdSrtB3oVFp4G3VHVvGbv81i8Nd-A62qgcmo0VDvOq_EaYJiSaM4fsx6oEqhHZfzhTcmcU4WjUA&code_challenge_method=S256&redirect_uri=http://localhost:8888/authorization");
            request.getRequestHeaders().put(Headers.AUTHORIZATION, "Basic " + encodeCredentials("admin", "123456"));
            connection.sendRequest(request, client.createClientCallback(reference, latch));
            latch.await();
            int statusCode = reference.get().getResponseCode();
            String body = reference.get().getAttachment(Http2Client.RESPONSE_BODY);
            Assert.assertEquals(400, statusCode);
            if(statusCode == 400) {
                Status status = Config.getInstance().getMapper().readValue(body, Status.class);
                Assert.assertNotNull(status);
                Assert.assertEquals("ERR12035", status.getCode());
                Assert.assertEquals("CODE_CHALLENGE_TOO_LONG", status.getMessage());
            }
        } catch (Exception e) {
            logger.error("Exception: ", e);
            throw new ClientException(e);
        } finally {
            IoUtils.safeClose(connection);
        }
    }

    @Test
    public void testCodePKCECodeChallengeInvalidFormat() throws Exception {
        final Http2Client client = Http2Client.getInstance();
        final CountDownLatch latch = new CountDownLatch(1);
        final ClientConnection connection;
        try {
            connection = client.connect(new URI("https://localhost:6881"), Http2Client.WORKER, Http2Client.SSL, Http2Client.BUFFER_POOL, OptionMap.create(UndertowOptions.ENABLE_HTTP2, true)).get();
        } catch (Exception e) {
            throw new ClientException(e);
        }
        final AtomicReference<ClientResponse> reference = new AtomicReference<>();
        try {
            ClientRequest request = new ClientRequest().setMethod(Methods.GET).setPath("/oauth2/code?response_type=code&client_id=59f347a0-c92d-11e6-9d9d-cec0c932ce01&code_challenge=G$IiZShhVObyvaTrpkPM8VPmtMkj_qnBWlDwE7uz90s&code_challenge_method=S256&redirect_uri=http://localhost:8888/authorization");
            request.getRequestHeaders().put(Headers.AUTHORIZATION, "Basic " + encodeCredentials("admin", "123456"));
            connection.sendRequest(request, client.createClientCallback(reference, latch));
            latch.await();
            int statusCode = reference.get().getResponseCode();
            String body = reference.get().getAttachment(Http2Client.RESPONSE_BODY);
            Assert.assertEquals(400, statusCode);
            if(statusCode == 400) {
                Status status = Config.getInstance().getMapper().readValue(body, Status.class);
                Assert.assertNotNull(status);
                Assert.assertEquals("ERR12036", status.getCode());
                Assert.assertEquals("INVALID_CODE_CHALLENGE_FORMAT", status.getMessage());
            }
        } catch (Exception e) {
            logger.error("Exception: ", e);
            throw new ClientException(e);
        } finally {
            IoUtils.safeClose(connection);
        }
    }

    /**
     * Without Authorization Header, a 401 status code is returned with empty body; However,
     * the header must include Negotiate
     *
     * @throws Exception
     */
    @Test
    public void testSpnegoUnauthorized() throws Exception {
        final Http2Client client = Http2Client.getInstance();
        final CountDownLatch latch = new CountDownLatch(1);
        final ClientConnection connection;
        try {
            connection = client.connect(new URI("https://localhost:6881"), Http2Client.WORKER, Http2Client.SSL, Http2Client.BUFFER_POOL, OptionMap.create(UndertowOptions.ENABLE_HTTP2, true)).get();
        } catch (Exception e) {
            throw new ClientException(e);
        }
        final AtomicReference<ClientResponse> reference = new AtomicReference<>();
        try {
            ClientRequest request = new ClientRequest().setMethod(Methods.GET).setPath("/oauth2/code?response_type=code&client_id=59f347a0-c92d-11e6-9d9d-cec0c932ce01&code_challenge=G$IiZShhVObyvaTrpkPM8VPmtMkj_qnBWlDwE7uz90s&code_challenge_method=S256&redirect_uri=http://localhost:8888/authorization");
            connection.sendRequest(request, client.createClientCallback(reference, latch));
            latch.await();
            int statusCode = reference.get().getResponseCode();
            String body = reference.get().getAttachment(Http2Client.RESPONSE_BODY);
            Assert.assertEquals(401, statusCode);
            Assert.assertTrue(body == null || body.length() == 0);
            HeaderMap headerMap = reference.get().getResponseHeaders();
            Assert.assertTrue(headerMap.size() > 0);
            HeaderValues values = headerMap.get(WWW_AUTHENTICATE);
            Assert.assertTrue(values.size() > 0);
            // Make sure that you have Negotiate in the response header.
            Assert.assertTrue(values.contains(NEGOTIATE.toString()));
        } catch (Exception e) {
            logger.error("Exception: ", e);
            throw new ClientException(e);
        } finally {
            IoUtils.safeClose(connection);
        }
    }

    /**
     * This time, we send the right www_authenticate header
     *
     * @throws Exception
     */
    @Test
    public void testSpnegoWwwAuth() throws Exception {
        Subject clientSubject = login("jduke", "theduke".toCharArray());

        Subject.doAs(clientSubject, new PrivilegedExceptionAction<Void>() {

            @Override
            public Void run() throws Exception {
                GSSManager gssManager = GSSManager.getInstance();
                GSSName serverName = gssManager.createName("HTTP/localhost", null);

                GSSContext context = gssManager.createContext(serverName, TestServer.SPNEGO, null, GSSContext.DEFAULT_LIFETIME);

                byte[] token = new byte[0];

                boolean gotOur302 = false;
                while (!context.isEstablished()) {
                    token = context.initSecContext(token, 0, token.length);

                    if (token != null && token.length > 0) {
                        final Http2Client client = Http2Client.getInstance();
                        final CountDownLatch latch = new CountDownLatch(1);
                        final ClientConnection connection;
                        try {
                            connection = client.connect(new URI("https://localhost:6881"), Http2Client.WORKER, Http2Client.SSL, Http2Client.BUFFER_POOL, OptionMap.create(UndertowOptions.ENABLE_HTTP2, true)).get();
                        } catch (Exception e) {
                            throw new ClientException(e);
                        }
                        final AtomicReference<ClientResponse> reference = new AtomicReference<>();
                        try {
                            ClientRequest request = new ClientRequest().setMethod(Methods.GET).setPath("/oauth2/code?response_type=code&client_id=59f347a0-c92d-11e6-9d9d-cec0c932ce01&code_challenge=GIDiZShhVObyvaTrpkPM8VPmtMkj_qnBWlDwE7uz90s&code_challenge_method=S256&redirect_uri=http://localhost:8080/authorization");

                            request.getRequestHeaders().put(AUTHORIZATION, NEGOTIATE + " " + FlexBase64.encodeString(token, false));
                            connection.sendRequest(request, client.createClientCallback(reference, latch));
                            latch.await();
                            HeaderMap headerMap = reference.get().getResponseHeaders();
                            HeaderValues values = headerMap.get(WWW_AUTHENTICATE);
                            Assert.assertTrue(values.size() > 0);

                            if (values.size() > 0) {
                                String header = getAuthHeader(NEGOTIATE, values);

                                byte[] headerBytes = header.getBytes(StandardCharsets.US_ASCII);
                                // FlexBase64.decode() returns byte buffer, which can contain backend array of greater size.
                                // when on such ByteBuffer is called array(), it returns the underlying byte array including the 0 bytes
                                // at the end, which makes the token invalid. => using Base64 mime decoder, which returnes directly properly sized byte[].
                                token = Base64.getMimeDecoder().decode(ArrayUtils.subarray(headerBytes, NEGOTIATE.toString().length() + 1, headerBytes.length));
                            }

                            int statusCode = reference.get().getResponseCode();
                            String body = reference.get().getAttachment(Http2Client.RESPONSE_BODY);

                            if (statusCode == StatusCodes.FOUND) {
                                HeaderValues locations = headerMap.get("location");
                                assertEquals(1, locations.size());
                                gotOur302 = true;
                            } else if (statusCode == StatusCodes.UNAUTHORIZED) {
                                assertTrue("We did get a header.", values.size() > 0);
                            } else {
                                fail(String.format("Unexpected status code %d", statusCode));
                            }
                        } catch (Exception e) {
                            logger.error("Exception: ", e);
                            throw new ClientException(e);
                        } finally {
                            IoUtils.safeClose(connection);
                        }
                    }
                }
                assertTrue(gotOur302);
                assertTrue(context.isEstablished());
                return null;
            }
        });

    }

    @Test
    @Ignore
    public void testMarketPlaceClient() throws Exception {
        final Http2Client client = Http2Client.getInstance();
        final CountDownLatch latch = new CountDownLatch(1);
        final ClientConnection connection;
        try {
            connection = client.connect(new URI("https://localhost:6881"), Http2Client.WORKER, Http2Client.SSL, Http2Client.BUFFER_POOL, OptionMap.create(UndertowOptions.ENABLE_HTTP2, true)).get();
        } catch (Exception e) {
            throw new ClientException(e);
        }
        final AtomicReference<ClientResponse> reference = new AtomicReference<>();
        try {
            ClientRequest request = new ClientRequest().setMethod(Methods.GET).setPath("/oauth2/code?response_type=code&client_id=f71a9df8-79db-4f30-9b28-d3ea90c83cf7&user_type=employee&redirect_uri=http://localhost:8080/authorization");
            request.getRequestHeaders().put(Headers.AUTHORIZATION, "Basic " + encodeCredentials("jduke", "theduke"));
            connection.sendRequest(request, client.createClientCallback(reference, latch));
            latch.await();
            int statusCode = reference.get().getResponseCode();
            String body = reference.get().getAttachment(Http2Client.RESPONSE_BODY);
            Assert.assertEquals(statusCode, 302);
        } catch (Exception e) {
            logger.error("Exception: ", e);
            throw new ClientException(e);
        } finally {
            IoUtils.safeClose(connection);
        }
    }


    protected static String getAuthHeader(final HttpString prefix, final HeaderValues values) {
        for (String current : values) {
            if (current.startsWith(prefix.toString())) {
                return current;
            }
        }
        fail("Expected header not found.");
        return null; // Unreachable
    }

}
